
                                                
   ▀████▀     ██     ▀████▀   ▀███▀     ██      
     ██      ▄██▄      ▀██     ▄█      ▄██▄     
     ██     ▄█▀██▄      ██▄   ▄█      ▄█▀██▄    
     ██    ▄█  ▀██       ██▄  █▀     ▄█  ▀██    
     ██    ████████      ▀██ █▀      ████████   
███  ██   █▀      ██      ▄██▄      █▀      ██  
 █████  ▄███▄   ▄████▄     ██     ▄███▄   ▄████▄
                                                
                                                
Welcome to the world of java 
Java was developed by james gosling at sun micro system but later sold it out to oracle 😂
java is object oriented and roubust it is complex but easy to under stand as per as my view of point 😂

before going deep into java lets take a small talk 

Program is composed of code and data There are two paradigrams in programing ie porcess oriented and object oriented process oriented is like code 
acting on data process oriented is decent when we have small program.When the program gets large the process oriented approach is hard , Thus 
difficult to manage the program to overcome this pop problems oop was born object orient is like data acting on code.using oop we can have many 
benefits like scalibility reuseability and easy to manage complexity 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

oop have 4 principles 

1.Abstraction 
2.Encapsulation 
3.Inherritance 
4.Polymorphism 

Abstraction 
We manage complexity with the help of Abstraction, Abstractionis implemented with the help of hierachial classification

Encapsulation
Encapsulationis the mechanism which is used to bind code and data it manipulates .It provides secuerity One of the best example of Encapsulation is 
class (all data and code resides within the class) 

Inherritance
Inherritancecan be defined as methedology according to which a object acquires the properties of other object Inherritance supports the concept of 
hierachial classification

Polymorphism
Polymorphism can be defined as using a item more than once aka reuseability of code A promient example of Polymorphism is interface 

Enough Small talk lets talk about java 😂 ☕️ 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Must do in java 

All java files are saved with extension of (.java) because in java source file is ofiicially a compilation unit In java class name must be same as file
name this is because in java all code resides within the class  

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

How java code is compiled 

javac=java compiler
jdk=java development kit
jvm=java virtual machine 
jre=java runtime environment

javac creates a file whose name is same as class but with extension of (.class) this file contains the byte code of the progarm this byte code is a 
intermediate representation of instruction that your jvm will execute When Java source code is compiled, each individual class is put into its own 
output file named after the class and using the .class extension. 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Java's syntax is a composed of whitespace identifiers literals comments opreators seperators and keywords and emotions(🌚)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

whitespace = ' '

Java is a free-form language. This means that you do not need to follow any special indentation rules.For instance,the  program could have been written
all on one line or in any other strange way you felt like typing it,as long as there was at least one whitespace character between each token that was
not already delineated by anoperator or separator.In Java, whitespace is a space, tab, or newline.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

comments = comments are elements in java which are ignored by compiler 

there are three types of comments 
// for single line 
/* ...*/ for multiline 
/**
  *
  */  for documentation 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

keywords = keywords can be defined as special words in java that depecites a special meaning to compiler In addition to keywords java reserves the 
following words true false and null 

keywords are 

----------------------------------------------------------------------------------------------------------------------
|                                                                                                                    |
|  abstract continue for new switch assert default goto package synchronized boolean do if private this break double |
|  implements protected throw byte else import public throws case enum instanceof return transient catch extends int |
|  short try char final interface static void class finally long strictfp volatile const float native super while    |
|                                                                                                                    |
----------------------------------------------------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Seperators = They are used to terminate a statement or to sperate a block of code 

semicolon ; - is the most used seperator and is used to termainate a statement
parentheses () - is used in multiple cases including defining a precedence of an expression control statements and loops
curly braces {} - are used to define local scope and define block of code they are also used to inilitize an arrray 
barckets [] -these are used to define arrya types and array size 
comma , - commas are used in many cases including using as seperators in for loops and in declaring multiple variables of same datatype 
period . - Used to separate package names from subpackages and classes. Also used to separate a variable or method from a reference variable. 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

identifiers = indentifiers can be defined as name given to memory location these are thought by user examples of identifiers are myvariable, myconsttant,
myarray or any thing user wishes to name but they must not begin with a number because it may confuse compiler either it is variable or value and it 
must also must not have /  and - inbetween character.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Literals= literals are const values stored in variables example 69 , 420 , 94 ,007 , 'a' ,"mystringx" and many more 😂

Let's have a deep dive into them 💡 Before going to start about literals have have a small talk about number system 

There are mainly  kinds of number system 

---------------------------------------------------------------------------
|                                                                         |
|  NumberSystem      base           Composition                           |
|                                                                         |
|  binary             2              1,2                                  |
|  octal              8              0,1,2,3,4,5,6,7                      |
|  decimal           10              0,1,2,3,4,5,6,7,8,9                  |
|  hexadecimal       16              0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f      |
|                                                                         |
---------------------------------------------------------------------------

In the above table the base show how many type of character a number system is composed of, and the Composition tells about types of character it have 

Let's move back to literals 

Integer literals 
Any whole number value is an integer literal An integer literal can always be assigned to a long variable. However, to specify a long literal, you will
need to explicitly tell the compiler that the literal value is of type long. You do this by appending an upper- or lowercase L to the literal.
 For example, 0x7ffffffffffffffL or 9223372036854775807L is the largest long. An integer can also be assigned to a char as long as it is within range.

Floating point literals 
Floating-point literals in Java default to double precision. To specify a float literal, you must append an F or f to the constant. You can also
explicitly specify a double literal by appending a D or d. Doing so is, of course, redundant. The default double type consumes 64 bits of storage,
while the less-accurate float type requires only 32 bits.

Boolean literals
Boolean literals are simple. There are only two logical values that a boolean value can have, true and false. The values of true and false do not convert
into any numerical representation. The true literal in Java does not equal 1, nor does the false literal equal 0. In Java, they can only be assigned 
to variables declared as boolean, or used in expressions with Boolean operators.

Character literal
Characters in Java are indices into the Unicode character set. They are 16-bit values that can be converted into integers and manipulated with the 
integer operators, such as the addition and subtraction operators. A literal character is represented inside a pair of single quotes. All of the visible
ASCII characters can be directly entered inside the quotes, such as ‘a’, ‘z’, and ‘@’.

String literals
String literals in Java are specified like they are in most other languages—by enclosing a sequence of characters between a pair of double quotes.

There's a big daddy of constant 😂 - final

The final keyword is used to make variable hold a constant value i.e the value of the variabele never changes no matter 
what operation is done on it. Variables declared as final do not occupy memory on a per-instance basis.

syntax ~
final <datatype> <identifier> = <literal>

example ~
final int MY_DATA = 69;

It is a convention to use capital letter identifiers in case of final.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


.                                              🥶 DATA TYPES 🥶

Java’s safety and robustness comes from this fact. Let’s see what this means. First, every variable has a type, every expression has a type, and every 
type is strictly defined. Second, all assignments, whether explicit or via parameter passing in method calls, are checked for type compatibility.

Java's datatypes are mainly divided into 2 parts ~
1.Primitive      -    these are predefined in java   these are also called as simple datatype
2.Non Primitive  -    these are defined by users 

predefined datatypes are further defined into four groups which are ~
1.a-integers
2.b-floating point
3.c-character
4.d-boolean 

lets' have a deep dive into them 🫠

1.a Integers 

They are used to store numbers aka numbers except decimal/fraction type values In java they all are signed
Integers are divided into four groups namely ~

-------------------------------------------------------------------------------------
|  Name   Width(in bits)   range                                                    |
|                                                                                   |
|  byte      8             -128 to 127                                              |
|  short    16             -32768 to 32767                                          |
|  int      32             -2,147,483,648 to 2,147,483,647                          |
|  long     64             -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807  |
|                                                                                   |
-------------------------------------------------------------------------------------

1.b Floating point 

They are also known as real numbers. Sometimes evaluating expression we need point precise values To counter this problem Float and Double are born 

-------------------------------------------------------------------------------------
|  Name   Width(in bits)     range                                                  |
|                                                                                   |
|  float    32               1.4e–045 to 3.4e+038                                   |
|  double   64               4.9e–324 to 1.8e+308                                   |
|                                                                                   |
-------------------------------------------------------------------------------------

1.c Characters 

Java uses unicode to represent Characters unicode defines character set of all international languages 
The standard set of Characters known as ASCII has 0 to 127 character 
Extended characterset of ISO-Latin-1 ranges from 0 to 255

-------------------------------------------------------------------------------------
|  Name   Width(in bits)     range                                                  |
|                                                                                   |
|  char    16               0 to 65535                                              |
|                                                                                   |
-------------------------------------------------------------------------------------

1.d Boolean 

Boolean is for logical values it can only have two possible outcomes either true or false. The number of bytes in a boolean is a measure of its 
logical value. Its size is not defined in java it depends on compiler

-------------------------------------------------------------------------------------
|  Name   Width(in bits)     range                                                  |
|                                                                                   |
|  boolean    no fixed        not fixed, can only store true and false              |
|                                                                                   |
-------------------------------------------------------------------------------------

Non Primitive data type are datatypes which are defined by the user 

String and arrays - we will cover this after some essential topics are covered 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

.                                                🥶 variables 🥶


A variable is the basic storage unit in java program it have a type(datatype) identifier and an optional initilization
All variables have a scope and their lifeline (identifier is the name of the variable) 

let's take an example by declaring a variable 
int myvariable;  //declaring a variable 
myvariable=69;   //initilization of my variable 

here, int is the datatype and myvariable is an identifier and 69 is an integer literal or the value initilized to myvariable
The value of 69 is assigned by an operator we will discuss about operators after that 😉

we can declare multiple variables of same datatype at same time 
for example 
int a,b,c,d,e;
in the above expression these all variables are separated by an seperator that we have talked about earlier
we can also declare and initilize a variable at the same time this in terms of java is called Dynamic initilization
example of Dynamic inilitization ~
int myvariable=69;

Let's talk about life and scope of variables 
All variables defined within the class can be access by all the functions within the class these are also called as member variables 
A variable defined within the scope(block of code inside curly braces) cannot be accessiable outside the scope because variables defined within the 
scope are destroyed the their scope is left 

Type casting and type conversion 
When we transfer value of one datatype to another datatype there is either the loss of data or there's no lost of data if the transfer of value or 
copying of value is in same datatype that's does not have a problem 

In type conversion value of datatype is automaticially to another datatype by compiler But in type conversion value of conversion of one datatype 
must be smaller than other datatype for example
int a=10;
float b;
b=a;

Type casting aka narrowing conversion 
Type casting can be defined as storing a value of datatype with more range to a datatype with less range or (incompatiable)

to peform type casting must follow this 👇🏼
(target-datatype) current-datatype
float x;
int y;
y=(int)x;

Automatic type conversion ~ aka widening conversion
Java supports automatic type conversion, it happens only if ~
Two types are compatiable 
Destination type is larger than source type 

Automatic type promotion 
Java supports automatic type promotion in expression aka in an expression with multiple datatypes the result will automaticiallyn will be converted to
datatype with higher range 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

.                                            🥶 OPERATORS 🥶

Well well well ... you have survived till now ,😂 now lets give you more java concepts

operators are used to perform task on perands aka performs operations 

1. Arithmetic operator ~
Arithmetic operators are the most common used operator in java they are used in mathematical expression just like algebra. They are used to perform 
task on 2 operands but can be chained to perform complex tasks 

-----------------------------------------------------------------------
|                                                                     |
|     Operator                      Result                            |
|        +                        Addition                            |
|        –             Subtraction (also unary minus)                 |
|        *                     Multiplication                         |
|        /                         Division                           | 
|        %                         Modulus                            |
|       ++                        Increment                           |
|       +=                    Addition assignment                     |
|       –=                  Subtraction assignment                    |
|       *=                 Multiplication assignment                  |
|       /=                    Division assignment                     |
|       %=                     Modulus assignment                     | 
|       ––                        Decrement                           |
-----------------------------------------------------------------------


Increment and decrement operator ~
Increament/decrement operator are used in multiple cases like loops. They are quite helpful in irritations kinda stuff

-------------------------------------------------------------
|                                                           |
|  decrement(--)  decrease value of operand by 1 at a time  |
|  Increment(++)  increase value of operand by 1 at a time  |
|                                                           |
-------------------------------------------------------------

arithmatic compound operator ~
+= is an arithmatic compound operator this is used to assign value to itself with addition to any more operator 
for example 
declaring a just for example 
int a;
first approach 
a=a+69;
second approach 
a+=1;
as you can see in the first approach there is so,e extra line of code while second approach is more efficient and understandable 

likewise first approach we can have many others compound assignment operator 
aka~
-=
*=
/=
%=


2. bitwise operator ~
these operator perform functions on bits there are multiple bitwise operator ~

----------------------------------------------------
|   operator     |    name                         | 
|----------------|---------------------------------|
|      ~         | bitwise uranary not             |
|      &         | bitwise AND                     | 
|      |         | bitwise OR                      |
|      ^         | bitwise exclusive OR            |
|     >>         | shift right                     |
|    >>>         | shift right zero fill           | 
|     <<         | shift left operator             |
|     &=         | bitwise AND assignment          | 
|     |=         | bitwise OR assignment           |
|     ^=         | bitwise exclusive or assignment |
|    >>=         | shift right assignment          | 
|    >>>=        | shift right zero fill asignment | 
|    <<=         | shift left assignment           | 
|                |                                 | 
----------------------------------------------------


lets talk buisness 😂

~ bitwise uranary NOT 
is also called complement operator it is an uranary operator it reverts the bits in of the varibale on which operation is being performend 

& bitwise AND
work between bits of two operand if the both bits are true it will return true aka 1 else it will return false 

| bitwise OR 
work between two bits of two operand if one of the bits is true the answer is true aka 1 else the answer will be false 

^ bitwise XOR
work between two bits of two operand if both bits are same the answer will be false else the answer will be true 

>> shift right operator 
syntax =variable>>number
this operator isn used to shift bits in the value to the right place by the number given by the user 
for example 
int a =32;
a=a>>2
100000
after shifting the value by two digits 
1000
in this operator the bits in the last is deleated 

>>> unsigned right shift operator 
syntax variable>>>number 

<< right shift operator 
syntax variable<<number
a=5;
a<<2;
The above exapmle will output answer of 20 
this is because the bits are added to the backside of the bits of the value of the variable 
another example of this operator ~
a=8;
int b=a<<2;
answer =32
this is because the value of a is stored in bits aka 1000
when the operation is done the number input by the user is added in the back of the bits of the variable 
in this case when the operation is done two zeros are added at the back of the bits of the varibale 

Just like we earlier studied compount assignment Operator there's a same typo in bitwise operator 
for example 
int a =5;
a=a<<2;
answer will be 20
whe can also do ~
int a ;
a<<=2;
same approach is followed in compound bitwise assignment operator aka |=,&=,^=,<<=,>>=

3. Relational operators 
Relational operators is used to find relation between two operands 

-----------------------------------------------------------------------------------------------
|            |                                                                                |
|  operator  |                          result                                                |
|            |                                                                                |
|   ==       |    checks whether both operands are equall or not                              |
|   !=       |    checks whether both operands are not equall or equall                       |
|   >        |    check if the right operator is smaller than left                            |
|   <        |    check whether the left operator is bigger the the right                     |
|   >=       |    check whether the right operator is lesser than or equal to left operator   |
|   <=       |    check whether the left  operator is lesser than or equal to right operator  |  
|            |                                                                                |
-----------------------------------------------------------------------------------------------

4.Short circut logical operator 
java provides special boolean logical operator which is not found in many other languages These are also known as short-circut logiacl operators 

As you can see from the preceding table, the OR operator results in true when A is true, no matter what B is. Similarly, the AND operator 
results in false when A is false, no matter what B is. If you use the || and && forms, rather than the | and & forms of these operators, 
Java will not bother to evaluate the right-hand operand when the outcome of the expression can be determined by the left operand alone.
This is very useful when the right-hand operand depends on the value of the left one in order to function properly.

5. Boolean logical operator
The boolean logical operators do work only on boolean operands these are just logical operators working on boolean operands boolean logiacal 
operator have all bitwise opeartor and bitwise assignment operator and most used &&  and || this && and || can be used to chain multiple conditions 

6. The ? operator
The ? is a ternary operator this can be used in multiple cases like it can replace if-then-else
Syntax~
expression1 ? expression2 : expression3
example of  ? operator ~
i = -10;
k = i < 0 ? -i : i; // get absolute value of i
System.out.print("Absolute value of ");
System.out.println(i + " is " + k); 
output of the following will be -  Absolute value of -10 is 10

ahhhhhhh 🌚 lets have one last topic related to operator aka precedence
In most of the languages there's a precedence of operators aka which operation is going to be performed first 
In a java expression seperators can be used to define precedence 

Highest
() [] .
++  ––  ~  !
*  /  %
+  –
>>  >>>  <<
>  >=  <  <=
==  !=
&  ^  |
&&
||
?:
=  op=
lowest

in addition to precedence seperators do also simplify the meaning of the expression in most of the cases the associativity is left to right i.e 
the the precedence of an expression is same at the both side the left side will be operational first 

Arithmetic Operators > Relational Operators > Bitwise Operators > Boolean Logical Operators


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
         
.                                                🥶 CONTROL STATEMENTS 🥶


Control statements are the building blocks of a program they are used in countless algorithms they are used to control flow of programs 
Java have the following control statemnets 
1. Conditional Statements 
2. Loops 
 

Conditional Statements are also of three types 
1.A if 
1.B if else 
1.C if then else 
1.D switch 

Loops are further divided into three types namely 
2.A for loops 
2.B while loops
2.C Do while loops 

1.A if statement can be defined as a simple taks  i.e if the condition given satisfied the task will be performed 

syntax of if statement ~

if(condition)
{
  task ;
}

1.B if else - if else is the upgraded version of the if it contains a extra block which will be executed if the condition fails to satisfy

if(condition)
{
  task;
}
else
{
  task;
}

1.C if then else - In a nutshell, if then else can be described as multiple if and single else . If then else have multiple conditions chained 
to it in this control statement condition is checked once at a  time if all the conditions fails to satisfy it comes to else part the number of 
conditions is as per user's choice. But if the condition is satisfied at the starting it will not execute the other condition aka if the condition 
satisfies the upcomming will neither be checked nor executed  

if(condition){
  task;
}
else if(condition 2){
  task
}
else if(condition 3){
  task;
}
else if(condition 4){
  task;
}
else{
  task;
}

1.D switch case - here comes the real bully 😂 switch case is similar to if then else but compleately different in terms of syntax "I know you saw it 
comming 😂" switch case take operand and then checkes the multiple condition on it if the condition satisfies it will execute the task but if the all 
conditions fails to satisfy it will also have a defult case note the case parameters will not take a variable or boolean expression as an argument 

switch(operand)
{
case(constant):
task;
break;

case(constant):
task;
break;

case(constant):
task;
break;

default:
task;

}


lets talk about loops ~ they are also known as irritations control statements Loops are used to execute statements or set of statements multiple times
as per as user choice 

in java there are mainly three kinds of loops 
1.For loop
2.while loop
3.do while loops

2.A for loop - for loop is used to execute a statement multiple times it depends on the control variable. Control varibale is used in multiple cases like 
initilization, for checking the condition and control it to to manage no of irritations

for loop has the folowing syntax ~

for(initilization;condition;function on control variable)
{
  set of statements;
}

lets take a realk world example 

code ~

int i;
int j=10;
for(i=1;i<=j;i++)
{
  System.out.println("hello world);
}

the following code will print the hello world 10 times because the initial value of control variable is zero in this case the hello world will be printed 
till the control the control variable satisfies the condition in this case the hello world is printed 10 times because the value of control variable is 
incremented by 1 at a time if the value of the control variable is incremented by two the hello world will be printed 5 times 

2.B while loop- while loops is the most basic loop in java it mainly depends on the condition it will execute the task or 
set of statements till the condition satisfies 

its syntax ~

while(condition)
{
  task;
}

lets understand with a example ~
int j=10;
while(j>0)
{
  System.out.println("hello world" );
}

As output  the following code will print the hello world infinite time because the the condition is always true it will terminate the loop only when the 
condition fails to satisfy or we use jump statements this infinite case occurs same with all loops 

To make the irritations finite we must make a such a statement that will falsifies the condition 

lets make this loop finite 

int j=10;
while(j<0){
  System.out.println("hello world ");
  j--;
}

In the above case the value of j is being decreasing by 1 after each irritation there will be a time when the condition fails to satisfy in that case it 
will make control to jump out of the loop

2.C do while loop - in a nutshell do whie loop is same as while but in this case condition is checked first then the task is performed. 

syntax ~

do{
task;
while(condition);
}

In this case the task is performed one no matter what the condition is. On the other hand while loop check condition first note in the case of do while 
there's a semicolon after the while statement 

for exampe ~

int j=10;
do{
System.out.println("hello world");
while(j>10);
}

as the output the hello world will be printed one time even after the condition is false 

🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚🥶🌚


break and continue are the jump statements i.e they are used to skip one step of irritation or the set of irritation

break ~

For example leta have a senario in the mind that we are in a loop and our task has been compleated before all the irritations then the other irritations 
executed after our work are useless.
lets take an example 

our aim in this task is to print hello world ten times

for(int i=0;i<69;i++)
{
  System.out.println("hello world);
}

in the above example the hello world will be printed 69 times but as we have discussed earlier we wanted to print hello world ten time to counter this 
situation we will add break afterbour work gets compleated 

for(int i=0;i<69;i++){
  System.out.println("hello world);
  if(i==10){
    break;
  }
}

what we have done is we have added the break statement after the tenth irritations so what it will do it will will make control to jump out of the 
loop and the other irritatins will not be executed 

continue ~

continue is used to skip a irritation this is useful in cases when we want a specific irritation not to be execute

For example lets take a senario in which we want to print all numbers except 5 
Implementation ~

for(int i=1;i<=10;i++)
{
if(i==5)
{
continue;
}
else
{
System.out.println(i);
}
}
what we have done here is we have prrinted all number as the loop irritates but when our unwanted execute part comes we will skip that part using continue

 the output of the folloeing loop is 
 1
 2
 3
 4
 6
 7
 8
 9
 10 

There's also a jump statement called return it is used to return data from the method we will be learning this control statement in the later part


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
.              
.                                              🥶 CLASS 🥶

We have explored some basic which are the building blocks of a java program lets now move to phase 2 of java here we will be exploring the concept that
make java the real java. Before moving to classes, methods and  other topics lemme tell you about a method aka a function and class

Function/method - a function is a set of instructions that will be executed when it gets invoked we can pass our data to make functions to perform tasks 
on it. Functions may or may not return the value . These can be defined as the code which operate the data.

Class - in a nutshell class can be defined as a datatype defined by the user it have its own properties and behaviour it can have instances or classes 
inside it which can also have the same behaviour it can also have object which is an instance of a class. Class is a non primitive datatype.
We can define behaviour of a class as a methods and functions and its properties can be defined as data or variables it resides. 

Sample java program for a kick start ~

class myclass
{
int mydata=69;
float mydata2=420;
char mydata3='f';          
}

In the above example we have created a class using a class key-word. The class have a variable called mydata, mydata2 and mydata3.
We have defined its data type as we have discussed earlier it is a primitive data type , these data are the properties of the class named myclass. 
All the code and data reside within the class, the scope of these data starts with the opening curly braces and ends with the closing curly braces. 
Any method defined within the class can access these data. The data defined within the class are called member variables or intance variables as they 
are defined with the class they are accessiable to the instances created.  

Instace can be defined as a clone of class it can have same properties as its parent it have have access of the code and defined data reside with the 
class its made clone of. This also defiens the reueability of the code as there's no need to define the class and code again and again. But every 
instance created the every instance will have its own data if it has been taken from the user. 

It is important to remember that a class declaration only creates a template; it does not create an actual object.
Thus, the preceding code does not cause any objects of type myclass to come into existence.

myclass myobject = new myclass(); 

That above statement cretes an object name myobject this my object is an identifier thus creating a physical entity that myobect/instance of myclass 
will have clone of mydata, mydata2, mydata3. The dot (.) operator links the name of the object with the name of an instance variable.  
myclass.mydata;
we can assign our own values to it 
myclass.mydata=6996;
In short we use . operator to acces member methods and member variables 

The original myclass/template/virtual class is compleately seperate from its instance aka te behaviour of objects 
does not affect the code or the data of the main class 

declaring objects 

As told earlier creating a class you are creating a new data type. Obtaining a object is a two step process first you must declare variable of class 
type Second, you must acquire an actual, physical copy of the object and assign it to that variable. This can be done using new operator that new 
operator creates dynamically allocate space in the memory of object and return reference to it. That reference is stored in the variable 
Thus in java all objects are dynamically allocated 

The statement written above can be divided into two steps as discussed above 

//declaration of object 
myclass myobject;
//allocating the space 
myobject=new myclass();

The first line declare myobject as a reference of a object of type myclass. After the declaration of myobject this null value gets defined to object 
as till now it does not contain point reference to myclass, any attempt to use myobject after declaration will result in compile time error 

The second line allocates an actual object and assign reference to it myclass. In reality myobject just hold the memory address of of myclass.

NEW KEWWORD ~
As just explained new keyword allocated space in the memory dynamicially 

class-var = new classname( );

Here class is the datatype and var is the variable of datatype class. After the following new there's a constructor to initilize member variables of 
the class. We need to implement non primitive data aka objects type using new operator Let’s once again review the distinction between a class and 
an object. A class creates a new data type that can be used to create objects. That is, a class creates a logical framework that defines the relationship 
between its members. When you declare an object of a class, you are creating an instance of that class. Thus, a class is a logical construct.
An object has physical reality. (That is, an object occupies space in memory.) It is important to keep this distinction clearly in mind.


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                               🥶 FUNCTIONS AND METHODS 🥶


methods and functions are nearly the same they both have set of instructions they both can have arguments by whhich they can accept input from the user 
they both may or may not return the value, but the difference comes when the calling them i.e invoking them a function is called independently while a 
method is called using a reference this means a function is called without creating the instance of the class while a method is called by createing a 
instance/object of the class.

Every java program have a main function lets understand it with a example 

import java.util.*;
class myclass
{
  public static void main(String[] args)                                             @java main function
  {
   System.out.println("be water my friend ");                                        @code to print a statement
  }             
}

Have a  closer look at java's main function  

All program begins by calling the main function the main function is called when the program gets started. Main() is basicially a starting point of program 
you have often written this  👉🏽public static void main(String[] args)
This line have a meaning yeh it does have a meaning, f*** off java stereotypes 
public - it is a access specifier the main function is delcared as public as it is called outside the class 
static -the static is a keyword which calls main without creating a particular instance of a class 
void - main function is defined as void since it does not return any value 
String[] args- thre's a one parameter for the main function String[] args this is a array aka collection of insatances of class string
All code inside main function begins with open curly braces { and ends with closing curly braces }


System class , output stream , input stream  

Ass 😂 you can read the above program you will find that the line that outputs 'be water my friend' have multiple words chained before it. 
All of these words have a meaning 👇🏼
System- System is a predefined class which provides access to System 
out,in are used to get access to input output streams 
println(..)-println is a mehod which is used to console the the things inside it (in above example it was a string )


Just like the main function every function have its attributes 
Access specifier 
datatype it returns 
Name/identifier
Arguments - type of arguments and number of arguments it have 

these above properties can be used as a identity of a function as in java no function is same it has to different in terms of any of the above properties 
except access specifier.

Returning a value ~
As I have told earlier methods and functions can return value of the datatype they are for example lets have a sample~

import java.util.*;
class myclass{
public int ans(){
  int x=23;
  int y=3;
  int multiply=x*y;
  return multiply;
}
class main{
public void main(){
myclass ob=new myclass();
ob.ans();
  }
}
}

In above example the the function ans() is called with the reference of object it will return 69 because this function is of integer datatype in order to 
avoid return of values we can also declare our function as void. One more thing function does not return non primitive data type

Function can be invoked inside their own function this is case is called recursion or function of same datatuype can 
be returned in its return part

we can also compute and return at the same time for example we could have done in the above program is ~
return x*y;

Method with parameters ~

As we have dioscussed earlier we can pass input to function and methods to perforn operations on them this can be done by passing data through arguments 
this this also open doors to method overloading 

for example ~

import java.util.*;
class myclass{
public int ans(int x,int y){
  int multiply=x*y;
  return multiply;
}
class main{
public void main(){
myclass ob=new myclass();
int x=23;
int y=3;
ob.ans(x,y);
  }
}
}

here we have passed the variables as arguments to perform data on it there no limit on no of arguments and type of arguments, but before letting input 
inside  the function will insure and checks the data type of the arguments this is because java is a secure and robust language. 

The sequencce of type of arguments and no of arguments opens door to method overloading aka Polymorphism - using a function more than one time 

import java.util.*;
class myclass
{
 public int ans(int x,int y){
   int multiply=x*y;
   return multiply;
 }
 public int ans(int x,int y,int z){
     int multiply =x*y*z;
     return multiply;
 }
 class main
 {
  public void main()
   {
   myclass ob=new myclass();
   int x=23;
   int y=3;
   int z=1;
   ob.ans(x,y);
   ob.ans(x,y,z);
   }
 }
}

In the above examplpe we have used the ans(..) method multiple times using different arguments 

There a special function which is called constructor a constructor is used to inilitize member variables it gets invoked at the time a object is 
created it has a name which is as same as class name 

example of constructor 

import java.util.*;
class myclass
{
 int x;
 myclass(int myx){
     x=myx;
 }
 public void dispaly()
 {
     System.out.println(x);
 }
 class main
 {
  public void main()
   {
    Scanner in=new Scanner(System.in);
    System.out.println("input value to initilize it to the class variable ");
    int myx=in.nextInt();
   myclass ob=new myclass(myx);
   ob.dispaly();
  
   }
 }
}

in the above example
variable x is the class variable 
myclass(int myx) is the constructor with argument myx it assigns the value of myx to the x this constructor gets invoked when the object is created 
Note: if yoy want to pass value to the constructor make sure input is taken first 
display() - is a member function which prints the value of class variable aka x 

The constructor neither have datatype nor return value but just a name same as class this is because inplict type return type of the class Just like 
methods they can also be oveloaded just like functions constructor is class type itself 

example 

import java.util.*;
class myclass
{
 int x1,x2;
 myclass(int myx1){
     x1=myx1;
 }
 myclass(int myx1,int myx2){
     x1=myx1;
     x2=myx2;
 }
 public void dispaly1()
 {
     System.out.println(x1);
     
 }
 public void dispaly2()
 {
     System.out.println(x1+""+x2);
     
 }
 class main
 {
  public void main()
   {
    Scanner in=new Scanner(System.in);
    System.out.println("input value to initilize it to the class variable ");
    int myx1=in.nextInt();
    int myx2=in.nextInt();
   myclass ob1=new myclass(myx1);
   ob1.dispaly1();
   myclass ob2=new myclass(myx1,myx2);
   ob2.dispaly1();

   }
 }
}

Garbage collection ~

Since objects are dynamically allocated by using the new operator, you might be wondering how such objects are destroyed and their memory released 
for later reallocation. Java takes a different approach; it handles deallocation for you automatically. The technique that accomplishes this is 
called garbage collection

Garbage collection only occurs sporadically (if at all) during the execution of your program. It will not occur simply because one or more objects 
exist that are no longer used.

The finalize() method ~

By using finalization, you can define specific actions that will occur when an object is just about to be reclaimed by the garbage collector.

To add a finalizer to a class, you simply define the finalize( ) method. The Java run time calls that method whenever it is about to recycle an 
object of that class. Inside the finalize( ) method, you will specify those actions that must be performed before an object is destroyed.
The garbage collector runs periodically, checking for objects that are no longer referenced by any running state or indirectly through other 
referenced objects. Right before an asset is freed, the Java run time calls the finalize( ) method on the object.
The finalize( ) method has this general form:
protected void finalize( ) 
{
// finalization code here 
}


Here, the keyword protected is a specifier that prevents access to finalize( ) by code defined outside its class. It is important to understand that 
finalize( ) is only called just prior to garbage collection. It is not called when an object goes out-of-scope, for example. This means that you cannot 
know when—or even if—finalize( ) will be executed. Therefore, your program should provide other means of releasing system resources, etc., used by the 
object. It must not rely on finalize( ) for normal program operation.

Using object as parameter ~

Just like variables objects can also be passed as a parameter lets understand it with a example 
Lets have a closer look at argument passing 

there are two ways that a computer can pass a argument 
1.call by value 
2.call by reference 

1.call by value ~
This approcah copies the value of an argument into the sub routine of the method therefore changes made to the sub routine haev noi change to the 
argumnent When we have to pass a primitive type we uses call by value 

2. call by reference ~
In this approach a reference to the argument is passed inside the subroutine reference is used to accesss the actual argument specified in the call.  
This means that changes made to the parameter will affect the argument used to call the subroutine when we have to pass objects we uses call by reference 
because in other terms 0object is a refernced variable

As we discussed earlier when we have to pass primitive type we uses call by value so lets have a small example 

// Primitive types are passed by value.
class Test
{
void meth(int i, int j)
{
i *= 2;
j /= 2; 
}
}
class CallByValue 
{
  public static void main(String args[]) 
  {
  Test ob = new Test();
  int a = 15, b = 20;
  System.out.println("a and b before call: " + a + " " + b);
  ob.meth(a, b);
  System.out.println("a and b after call: " +a + " " + b);
  } 
}

Output

a and b before call: 15 20
a and b after call: 15 20

As you can see, the operations that occur inside meth( ) have no effect on the values of a and b used in the call; their values here did not change to 30 
and 10. When you pass an object to a method, the situation changes dramatically, because objects are passed by what is effectively call-by-reference. 
Keep in mind that when you create a variable of a class type, you are only creating a reference to an object. Thus, when you pass this reference to a 
method, the parameter that receives it will refer to the same object as that referred to by the argument. This effectively means that objects are passed 
to methods by use of call-by-reference. Changes to the object inside the method do affect the object used as an argument.
 For example, consider the following program:
// Objects are passed by reference.


class Test
{
int a, b;
Test(int i, int j)
{
a = i;
b = j;
}
// pass an object
void meth(Test o)
{
o.a *= 2;
o.b /= 2; 
}
}
class CallByRef {
public static void main(String args[]) {
Test ob = new Test(15, 20);
System.out.println("ob.a and ob.b before call: " +ob.a + " " + ob.b);
ob.meth(ob);
System.out.println("ob.a and ob.b after call: " +ob.a + " " + ob.b);
} 
}

output~

ob.a and ob.b before call: 15 20
ob.a and ob.b after call: 30 10

As you can see, in this case, the actions inside meth( ) have affected the object used as an argument. As a point of interest, when an object reference 
is passed to a method, the reference itself is passed by use of call-by-value. However, since the value being passed refers to an object, the copy of 
that value will still refer to the same object that its corresponding argument does.

returning objects ~

A method can return any type of data its been created of 
lets understand it with a example ~

import java.util.*;
class myclass
{
int x;
myclass(int x)
{
this.x=x;
}
public myclass check()
{
 myclass myobject =new myclass(420);
 return myobject;
}
class Main
  {
    public void main(String[] args)
    {
    Scanner in=new Scanner(System.in);
    System.out.println("input first value ");
    int x=in.nextInt();
    System.out.println("input second value ");
    int y=in.nextInt();
    myclass ob=new myclass(69);
    ob.check();
    } 
  }
}

In the above functionI have created myclass object called myobject inside check function this function is of myclass datatype ie this function will return 
object. when the following program is compiled check function is called in which myobject is created and returned.

Recursion ~
recursion can be defined as a process in which a function/method calls itself in side its own body this can be done to do recursive tasks, the method that 
deals with recursion is called recursive method.

A simple example of a recursive program ~

import java.util.*;
class myclass
{

public int myfunction(int x)
{
    
    if(x>69){return 69;}
    else{
    System.out.println(x);
    return myfunction(x+1);
    }
    
 }
 class Main
  {
    public void main(String[] args)
    {
     myclass ob=new myclass();
     ob.myfunction(0);
    } 
  }
}

In the above example myfunction(..) is returning itself in its body its is returning because both funcions are of same type aka int, this function could 
have long lasted till the ram runs of to prevent this situation we implements a condition called recursive case this will be executed when or make it 
executed when our work gets done. 

Static ~

Static is used to make member elements accessed before objects of a class are even created 
Methods declared as static have the following restrictions 
1. They must access only static data.
2. They can only call other static methods.
3. They cannot refer to this and super in any way.

If you need to do computation in order to initialize your static variables, you can declare a static block that gets executed exactly once, when the class 
is first loaded. 

class myclass
{

  static class_variable1=3;
  static class_variable2;

  static
  {
    System.out.println("Static block has been initilized first independent to sequence of functions ");
    class_variable2=class_variable1*4;
  }

  static void mymethod(int my_variable)
  {
    System.out.println("The vaue of my_variable is = "+my_variable);
    System.out.println("The vaue of class_variable1 is = "+class_variable1);
    System.out.println("The vaue of class_variable2 is = "+class_variable2);
  }
  
  public static void main(Strings[] args)
  {
    mymethod(69)
  }
}

In the above code the class_variable1 and class_variable2 are declared static so they must be initilized in the static block if they are not initilized 
within the class this initilizing static block is executed only once when the class is first loaded 
Instance variables declared as static are, essentially, global variables. When objects of its class are declared,
no copy of a static variable is made. Instead, all instances of the class share the same static variable.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

.                                               🥶 INHERRITANCE🥶

Inherritance is one of the main concepts of the oops it opens doors to Implementation of  hierachial classification To pass sojme traits to the classes 
Inherritance is used this this helps class to have predefined traits including the properties it may defines

The class from which a class is inherits is called superclass
The class which gets inherited  from superclass is called derived-class/sub-class 

.                           Before talking about lets have a talk about access specifier ~

Acccess specifier/modifier in a nutshell can be defined as accessability of a member either it is limited to class or a class to other class or may 
even in the packages. These are used for encapsulation.

Java supports 4 access specifiers ~ 
1.Public 
2.Protected 
3.Private 
4.Default 

note: A java package is a group of similar types of classes, interfaces and sub-packages.

1.Public - Public has the highest level of accessability - A method, variable, class, declared can be accessed by any other class and methods and other 
packages

2.protected - This access specifier is used for methods and variables the methods and variable will be accessiable to other classes till they belong to 
the same package.

3.Private - Private has the lowest level of accessiability a variable class method declared in the class will be accessiable within the class only not 
even outside the class of same package. 

4.Default - in case of no access specifier defined, the variables and  methods will be accessiable to within and outside the class till they all belong 
to the same package.


Have a look at a simple example of Inherritance ~

import java.util.*;
class myclass
{
int base_class_variable=69;
public void myfunction_super()
{
   System.out.println("this the function of base class");
   System.out.println("the variable within the base class is = "+base_class_variable);
}
}
public class myclass_child extends myclass
{
int derived_class_variable=420;
public void myfunction_derived()
{
     System.out.println("this the function of super class");
     System.out.println("the variable within the derived class is = "+base_class_variable+" and "+derived_class_variable);        
} 
}
 class Main
  {
    public void main(String[] args)
    {
     myclass_child ob_myclass_child =new myclass_child();
     ob_myclass_child.myfunction_derived();
    } 
  }

In the above example there's a class - myclass which is the parent class this parent class have a function called 
myfunction_super and a class variabele called base_class_variable which has a datatype of int and a value of 69 
What we have done here is we have created a class myclass_child but with capabilities of myclass aka its member 
variable and member methods. To get these properties we have used extends keywords the the line above suggests 
myclass_child extends the capabilities of myclass 

When the program gets run the object/instance of myclass_child is created thus we have a physical entity when we invoke 
the function of myclass_child it outputs the value of both variable aka variable of super class and variable of derived
class, the function of derived class was able to access the the members becasue this myclass_child is a derived from 
the myclass as the basic biology also suggests the child will have the properties and behaviour of its parents 
hence the beauty of inherritance.

Constructor calling by the sub class 
When the object of the sub class is created all constructors of the main class including all parent's class constructor are called.

Lets have a quick example~

import java.util.*;
class myclassa
{
    myclassa()
    {
        
        System.out.println("The constructor of mainclass have been invoked ");
        
    }
}
class mysubclassb extends myclassa
{
   mysubclassb()
   {
       
       System.out.println("The constructor of subclass have been invoked ");
       
   }
}
 public class mysubclassc extends mysubclassb{
    
    mysubclassc()
   {
       
       System.out.println("The constructor of subclass of subclass have been invoked ");
       
   }
}
    
class main
{
   public void main()
  {
          Scanner in=new Scanner(System.in);
          mysubclassc ob=new mysubclassc();
  }
}

output of the following program is ~

The constructor of mainclass have been invoked 
The constructor of subclass have been invoked 
The constructor of subclass of subclass have been invoked 

Lets understand the power of access modifier ~

import java.util.*;
class myclass
{
int base_class_variable=69;
private int base_class_variable2=420;
public void myfunction_super()
{
   System.out.println("this the function of base class");
   System.out.println("the variable within the base class is = "+base_class_variable);
}
}
public class myclass_child extends myclass
{
int derived_class_variable=420;
public void myfunction_derived()
{
     System.out.println("this the function of super class");
     System.out.println("the variable within the derived class is = "+base_class_variable+" and "+derived_class_variable+" "+base_class_variable2);        
} 
}
 class Main
  {
    public void main(String[] args)
    {
     myclass_child ob_myclass_child =new myclass_child();
     ob_myclass_child.myfunction_derived();
    } 
  }

The above program will not be executed because the derived class' function is accessing the base_class_variabele2
which is not accessiable because it is defined as private, as we discussed earlier private members are only accessiable
within the class only, while the base_class_variable is accessiable because its access modifier is set to be default 
which made variable and methods accessiable outside the class till they are in the same package. Protected is nearly 
same as public but its not ment for classes declared within a class aka a protected class inside a class will not be 
accessiable to class outside its ancestor class.

Final ~

Apart from storing constant final have also have 2 use cases in inherriatance 
1.If the main class is declared final than the subclass will not be inherrited.
2.Similarly it also prevents overriding - which is when a super class have a method id same as subclass method id the method of super class gets 
overrided by subclass method for example ~

import java.util.*;
class myclass
{
    public void display()
    {
        System.out.println("this is the method of the main class ");
    }
}
public class mysubclass extends myclass
{
    public void dispaly()
    {
        System.out.println("this is the method of subclass");
    }
}
    
    class main
    {
        public void main()
        {
          Scanner in=new Scanner(System.in);
          mysubclass ob=new mysubclass();
          ob.display();
        }
    }



Super ~

Super in a nutshell can be defined as keyword used to access members of super class
1. To invoke the constructor of the superrclass
There may be a case when the variabels of the super class is defined as private thus as we discussed an example earlier 
those members cannnot be accessed outside of the class,💥 boom here comes super which help subclass to access the data 
members of super class even if they are declared private.
2. To invoke the method of super class in case of overriding 
3. To access the member variable of the super class. 

super in case of accessing the variable of superclass
super.variable;

super in case of invoking the constructor of the superclass 
super(arguments)

super in case of accessing methods 
super.method();

lets understand it with an example with public variables 

import java.util.*;
class myclass
{
 int base_class_variable;
 int base_class_variable2;
myclass(int a,int b)
{
    base_class_variable=a;
    base_class_variable2=b;
}
}

public class myclass_child extends myclass
{
int derived_class_variable;
myclass_child()
{
     super(94,420);
     derived_class_variable=420;
}
public void myfunction_derived()
{
     System.out.println("this the function of derived class");
     System.out.println("the variable within the base class is = "+base_class_variable+" and the variable of the derived class is "+derived_class_variable);        
} 
}

 class Main
  {
    public void main(String[] args)
    {
     myclass_child ob_myclass_child =new myclass_child();
     ob_myclass_child.myfunction_derived();
    } 
  }

The output of the above program:
this the function of derived class
the variable within the base class is = 94 and the variable of the derived class is 420

In the above code the super(); is accessing the member variables of the super class in other words it is invoking the 
constructor of the superclass. 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




