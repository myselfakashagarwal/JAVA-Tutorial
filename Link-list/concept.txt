
                                                                                                                                     
â–€â–ˆâ–ˆâ–ˆâ–ˆâ–€       â–€â–ˆâ–ˆâ–ˆâ–ˆâ–€   â–€â–ˆâ–ˆâ–ˆâ–„   â–€â–ˆâ–ˆâ–ˆâ–€   â–€â–ˆâ–ˆâ–ˆâ–ˆâ–€ â–€â–ˆâ–ˆâ–ˆâ–€    â–€â–ˆâ–ˆâ–ˆâ–€â–€â–€â–ˆâ–ˆâ–ˆ    â–€â–ˆâ–ˆâ–ˆâ–€â–€â–€â–ˆâ–ˆâ–„               â–€â–ˆâ–ˆâ–ˆâ–ˆâ–€       â–€â–ˆâ–ˆâ–ˆâ–ˆâ–€    â–„â–ˆâ–€â–€â–€â–ˆâ–„â–ˆ   â–ˆâ–ˆâ–ˆâ–€â–€â–ˆâ–ˆâ–€â–€â–ˆâ–ˆâ–ˆ
  â–ˆâ–ˆ           â–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–„    â–ˆ       â–ˆâ–ˆ   â–„â–ˆâ–€        â–ˆâ–ˆ    â–€â–ˆ      â–ˆâ–ˆ    â–€â–ˆâ–ˆâ–„               â–ˆâ–ˆ           â–ˆâ–ˆ     â–„â–ˆâ–ˆ    â–€â–ˆ   â–ˆâ–€   â–ˆâ–ˆ   â–€â–ˆ
  â–ˆâ–ˆ           â–ˆâ–ˆ       â–ˆ â–ˆâ–ˆâ–ˆ   â–ˆ       â–ˆâ–ˆ â–„â–ˆâ–€          â–ˆâ–ˆ   â–ˆ        â–ˆâ–ˆ     â–€â–ˆâ–ˆ               â–ˆâ–ˆ           â–ˆâ–ˆ     â–€â–ˆâ–ˆâ–ˆâ–„            â–ˆâ–ˆ     
  â–ˆâ–ˆ           â–ˆâ–ˆ       â–ˆ  â–€â–ˆâ–ˆâ–„ â–ˆ       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆ      â–ˆâ–ˆ               â–ˆâ–ˆ           â–ˆâ–ˆ       â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„        â–ˆâ–ˆ     
  â–ˆâ–ˆ     â–„     â–ˆâ–ˆ       â–ˆ   â–€â–ˆâ–ˆâ–„â–ˆ       â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ         â–ˆâ–ˆ   â–ˆ  â–„     â–ˆâ–ˆ     â–„â–ˆâ–ˆ               â–ˆâ–ˆ     â–„     â–ˆâ–ˆ     â–„     â–€â–ˆâ–ˆ        â–ˆâ–ˆ     
  â–ˆâ–ˆ    â–„â–ˆ     â–ˆâ–ˆ       â–ˆ     â–ˆâ–ˆâ–ˆ       â–ˆâ–ˆ   â–€â–ˆâ–ˆâ–„       â–ˆâ–ˆ     â–„â–ˆ     â–ˆâ–ˆ    â–„â–ˆâ–ˆâ–€               â–ˆâ–ˆ    â–„â–ˆ     â–ˆâ–ˆ     â–ˆâ–ˆ     â–ˆâ–ˆ        â–ˆâ–ˆ     
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„   â–„â–ˆâ–ˆâ–ˆâ–„    â–ˆâ–ˆ     â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„   â–ˆâ–ˆâ–ˆâ–„   â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„   â–ˆâ–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€       â–„â–ˆâ–ˆâ–ˆâ–ˆâ–„   
                                                                                                                                     
                                                                                        

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Intro ~

linked list in my opinion explores the true concepts of the oop. A linked list is composed of nodes every node have two major parts data and reference part 
A node is a non primitive data type i.e data type created by the user. Many nodes connect together with the help of reference part together making a linked 
list, these nodes are stored randomly in the memory thus losing the reference of the first node may result in losing the list. It is a linear dynamic 
data structure 

Linked list have the following advantages ~
1. No boundatinns on size unlike array
2. These are stored in the memory randomly       
3. Its size can be increased during the runtime 

list are of many types ~
1. Singly linked list 
2. Doubly linked list 
3. circular linked list 
4. Doubly circular linked list 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Singly linked list ~

Singly linked list is the most basic linked list's node have two parts data and pointer(note: pointers are not in java this is just a reference).
Node is a non primitive datatype inplemented through class this class have two main datatype categories one regular to hold data like int char etc,
The another is same as class itself thus we can store node reference inside it, making a chain.

The first node of the linked list is caled head 
The reference of the last node always represent null
Nodes can be inserted at any point 
Deleation of the node can be done at any part 
Traverse cannot be done at any part directly 
Sorting is possible on the basics of data 

These are the main actions that can be performed on the singly linked list ~

add front 
A node is created and its next is pointed to the current list. Now we have a new node with our old linked list chained to it so what we gonna go we will
make our head point towords new node. 

add add back
A node is created. After creating node we will traverse till last aka last node.next =null this traverse will be performed on a duplicate list because we 
cannot travell till last directly, after reaching last we will simply replace null with the new node aka lastnode.next =newly created node.

add specific
A node is created. Just like other we will traverse till our location -1 this -1 is because (location -1)node.next represent our target position so if we 
wanna add our node at traget we will link the (location-1).next to newly maded node with attached with other nodes.   

delete front
Delete front is the easiest action just move the pointing head to next node old node reference will be deleated.

delete back
To delete back we will traverse till node before last node because second last node.next = last node && last node.next =null so if we connect both together 
there will be a loss of node before null booom our works is done. 

delete specific
To delete specifice we will traverse till our (location-1) because location -1 = traget && location.next.next = node after target so after reaching our 
location -1 we will dereference it next to the next.next boom we will loss node at target.  

display
Display is just traversing and printing at the same time 

Example of implementation of the linked list from the scratch ~

import java.util.*;
public class mylist
{
    Scanner in =new Scanner(System.in);
    public class bruh
    {
        String name;
        bruh next;
        bruh(String name)
        {
            this.name = name;
            this.next =null;
        }
    }
    bruh head; 
    bruh temporary;
    public void add_front()
    {
        System.out.println("Input the name of the bruh");
        String name = in.nextLine();
        bruh newbruh = new bruh(name);
        if(head==null)
        {
            head = newbruh;
        }
        else
        {
            newbruh.next = head;
            head = newbruh;
        }
    }
    public void add_back()
    {
        System.out.println("Input the name of the bruh");
        String name = in.nextLine();
        bruh newbruh = new bruh(name);
        if(head==null)
        {
            head= newbruh;
        }
        else
        {
           temporary =head;
           while (temporary.next!=null)
           {
               temporary = temporary.next;
           }
           temporary.next = newbruh;
        }
    }
    public void add_specific()
    {
        System.out.println("Input the name of the bruh");
        String name =in.nextLine();
        bruh newbruh =new bruh(name);
        System.out.println("Enter the position you wanna enter that");
        int initial = 1;
        int position1 = in.nextInt();    
        temporary = head;
        while(initial<position1-1)
        {
            temporary=temporary.next;
            initial++;
        }
        newbruh.next= temporary.next;
        temporary.next=newbruh;
    }
    public void delete_front()
    {
        head = head.next;
    }
    public void delete_back()
    {
        temporary = head; 
        while(temporary.next.next!=null)
        {
            temporary =temporary.next;
        }
        temporary.next = null;
    }   
    public void delete_specific()
    {        
        System.out.println("Enter the position you wanna delete");
        int initial = 1;
        int position2 = in.nextInt();
        temporary = head;
        while(initial<position2-1)
        {
            temporary=temporary.next;
            initial++;
        }
        temporary.next=temporary.next.next;
    }
        public void display()
    {
        temporary = head;
        while(temporary!=null)
        {
            System.out.println(temporary.name);
            temporary =temporary.next;
        }
    } 
    class main
    {
        Scanner in =new Scanner(System.in);
        public void main(String []args)
        {
            mylist ob =new mylist();
            ob.add_front();
            add_back();
            add_specific();
            delete_front();
            delete_back();
            delete_specific();
            ob.display();
        }
    }
}


Hope You have understood most of the code by yourself if not dont worry akash is here by your side ðŸ˜‰

Creating a node - We have created a node using the class as in the above program bruh is the class name this bruh have two datatype one is string 
and another is same as class itself. This another datatype is the key to the implementation as it can store reference the other node and that node 
can store another node reference thus Creating a chain now a question may arise in your mind that how do we initilize its member the thing we have 
done is we have used a constructor this constructor will initilize its string to passed in the argument and next currently at null. This constructor 
will be invoked at the time of creating a physical node/object/instace of the class which is being used to create node.

Every time I create a node I create a instance/physical-entity/object Nowww we have so may objects with data lying randomly in the memory than how do we 
create a chain out it ðŸ¤” simply using using datatype same as object, we will store node reference inside node reference and the chain goes on and on. 
As we know in java we can change refernce and store it in a variable we will use temporary node to make two references pointing at the same object 
thus we have secuerity of not losing our node. 

In the above program all data can be pass through arguments but to make things simple I have implemented with no arguments and have created node in the 
specific method. 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Doubly linked list ~

As you have gone through singly linked list you will be familioar that singly linked list canot be traversed backwards to solve this issue 
we have added one more reference variable just like next this new reference variable will store the reference of the previous node thus making linked 
doubble sided traverseful.

Every node have two reference variable 
back of head always represent null 
next of last node always represent null 
Deletion can be done at anypart 
Sorting is done on the basics of data 


Adde front: Fist create a new node , newnode.next=head , head.previous=newnode, now we have added node at front so we will update head head=newnode
as we are adding at the front the previous of the new node after beacoming head will represent null.

Add back: first create a new node, we will traverse till last node to do this we will indirectly traverse till last. After reaching last we will add 
our newly maded node by lastnode.next=new node, now we have added our new node to last node, now we will do other work newly added node .next=null
and newly made node.previous = last node. 

Add specific: First create a new node, we will traverse till node before target-node, becasue that node.next represent our traget, after reaching index before 
traget we will new node.next same as node before target, now we have two node pointing towards target, so we will make node traget-1.next = new node. 
Now we have added the node in between so we will do other stuff making newnode.previous=target-node-1 and new node.next.previous=new node.  

Delete front: we will move head to next and make previous of head to null, because previous of head represent null

Delete back: we will traverse till second last node because second-last node .next =last node. So after reaching there will will point next of send-last 
node to null thus removing all connections of the last node 

Delete Specific: We will traverse till target-1 and becasue target-1.next =target, so after reaching there will msimply made target-1.next=target-1.next.next
thus removing the reference of traget. At the same time we will update the previous target-1.next.previous=target-1

Display: We will traverse through linked list indirectly at the same time we will print the list


Example of implementation of the doubbly linked list from the scratch ~

import java.util.*;
class mydlist
{
    Scanner in=new Scanner(System.in);
    
      class bruh
      {
          String name;
          bruh previous;
          bruh next;
          bruh(String name)
          {
              this.name=name;
              previous=null;
              next=null;
          }
      }
      
      bruh head;
      
      public void add_front()
      {
          System.out.println("Input the name of the bruh");
          String name =in.nextLine();
          bruh newbruh=new bruh(name);
          if(head==null)
           { 
              head=newbruh;
           }
          else
           {
              newbruh.next=head;
              newbruh.previous=null;
              head.previous=newbruh;
              head=newbruh;
           }
      }
     
      public void add_last()
      {
          System.out.println("Input the name of the bruh");
          String name=in.nextLine();
          bruh newbruh =new bruh(name);
          if(head==null)
          {
              head=newbruh;
          }
          else
          {
              bruh temporary=head;
              while(temporary.next!=null)
              {
                  temporary=temporary.next;
              }
              temporary.next=newbruh;
              newbruh.previous=temporary;
          }
      }
    
      public void add_specific()
      {
          System.out.println("Input the name of the bruh");
          String name=in.nextLine();
          bruh newbruh=new bruh(name);
          System.out.println("Input index you wanna insert ");
          int desired_index=in.nextInt();
          int current_index=1;
          bruh temporary=head;
          if(temporary==null)
          {
              System.out.println("List is empty");
          }
          else
          {
              while(current_index!=desired_index-1)
              {
                temporary=temporary.next;
                current_index++;
              }  
              newbruh.next=temporary.next;
              temporary.next=newbruh;
              temporary.next.next.previous=newbruh;
              newbruh.previous=temporary;
          }
      }
    
      public void delete_front()
      {
          if(head==null)
          {
              System.out.println("This list is empty");
          }
          else
          {
              head=head.next;
          }
          head.previous=null;
      }
     
      public void delete_last()
      {
          if(head==null)
          {
            System.out.println("This list is empty");    
          }
          else
          {
            bruh temporary=head;
            while(temporary.next.next!=null)
            {
                temporary=temporary.next;
            }
            temporary.next=null;
          }
      }
      
      public void delete_specific()
      {
          bruh temporary=head;
          if(temporary==null)
          {
              System.out.println("The list is empty");
          }
          else
          {
              System.out.println("Input the index you wanna delete node at ");
              int desired_index=in.nextInt();
              int current_index=1;
              while(current_index!=desired_index-1)
              {
                  temporary=temporary.next;
                  current_index++;
              }
              temporary.next=temporary.next.next;
              temporary.next.previous=temporary;
          }
      }
      
      public void display_front()
      {
          if(head==null)
          {
              System.out.println("This list is empty");
          }
          else
          {
              bruh temporary=head;
              while(temporary!=null)
              {
                  System.out.print(temporary.name+" .next = ");
                  temporary=temporary.next;
              }
              System.out.println("NULL");
          }
      }

      public void display_back()
      {
          bruh temporary=head;
          while(temporary.next!=null)
          {
              temporary=temporary.next;
          }
          
          while(temporary!=null)
          {
             System.out.print(temporary.name+" .previous = ");
             temporary=temporary.previous;             
          }
          System.out.println("NULL");
      }
      

      class Main
      {
          public void main(String[] args)
          {
              mydlist ob=new mydlist();
              ob.add_front();
              ob.add_last();
              ob.add_specific();
              ob.delete_front();
              ob.delete_last();
              ob.delete_specific();
              ob.display_front();
              ob.display_back();
          }
      }
      
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Singly circular linked list ~

We have come across singly and doubly linked list but they all have one thing in common that is all have an end and cannot be traversed again and again 
to solve this problem what we have done is we have connected next of last node to the head thus making it circular and irritable.

Next of last node represent head
Every node have one reference variable 
Insertion can be done at any part 
deletion can be done at any part 

Add front : 

Add last : create a node, we will traverse till tail because tail represent last after reaching last we will point next of tail to new node and update tail
at last we will join the new tail to the head 

Add specific

Delete front : We will point head to next head thus losing the reference of the first node but wait we will also update the tail.next 

delete last After reaching node before tail we will simply point next second last node to the next of the lastnode/tail 

Delete specific 

display : Every time we add or delete the node we will update/calculate size of the list, so now we know the size of the list so we will traverse till the 
size of the list and print the node's data at the same time. 



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////